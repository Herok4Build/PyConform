#!/usr/bin/env python
"""
PyConform - Command-Line Interface

This is the command-line interface to the PyConform tool.  It takes input from
the command-line directly, and from an "output specification" file, which
defines the output dataset entirely.

COPYRIGHT: 2016, University Corporation for Atmospheric Research
LICENSE: See the LICENSE.rst file for details
"""

from os.path import exists
from glob import glob
from json import load as json_load
from collections import OrderedDict
from argparse import ArgumentParser, ArgumentTypeError
from warnings import simplefilter
from datetime import datetime

from pyconform.datasets import InputDataset, OutputDataset
from pyconform.dataflow import DataFlow
from pyconform.flownodes import ValidationWarning


#===================================================================================================
# chunk - Dimension/Chunksize Argument
#===================================================================================================
def chunk(arg):
    try:
        name, size_str = arg.split(',')
        size = int(size_str)
        return name, size
    except:
        raise ArgumentTypeError("Chunks must be formatted as 'name,size'")


#===================================================================================================
# dtstr - Datetime String Argumnet
#===================================================================================================
def dtstr(arg):
    try:
        dtargs = ' '.join(arg.split()).split(' ')
        if len(dtargs) == 1:
            dargs = dtargs[0]
            targs = None
        else:
            dargs, targs = dtargs
        yr, mon, dy = map(int, dargs.split('-'))
        if targs:
            hms = map(int, targs.split(':'))
        else:
            hms = (0, 0, 0)
        return datetime(yr, mon, dy, *hms)
    except:
        raise ArgumentTypeError("Datetime strings must be formatted as 'YYYY-MM-DD [hh:mm:ss]'")


#===================================================================================================
# Command-line Interface
#===================================================================================================
def cli(argv=None):
    desc = """This is the PyConform command-line tool.  This scripts takes
              input from the command-line and a predefined output
              specification file (specfile)."""

    parser = ArgumentParser(description=desc)
    parser.add_argument('-c', '--chunk', dest='chunks', default=[],
                        metavar='NAME,SIZE', action='append', type=chunk,
                        help='Chunk sizes for each dimension specified in the '
                             'output specification file.  Data will be read/written '
                             'in sizes given by these chunks. [Default: no chunking]')
    parser.add_argument('-f', '--specfile', default=None, metavar='SPECFILE', type=str,
                        help='JSON-formatted output specification file '
                             '[REQUIRED]')
    parser.add_argument('-e', '--error', default=False, action='store_true',
                        help='Whether to error when validation checks do not pass '
                             '(True) or simply print a warning message (False) '
                             '[Default: False]')
    parser.add_argument('--mindate', default=None, type=dtstr,
                        help='Minimum datetime to write time-series data to file.  The '
                             'variable(s) with time units will be bounded from below by this '
                             'value, and corresponding dimensions will be similarly bounded.')
    parser.add_argument('--maxdate', default=None, type=dtstr,
                        help='Maximum datetime to write time-series data to file.  The '
                             'variable(s) with time units will be bounded from above by this '
                             'value, and corresponding dimensions will be similarly bounded.')
    parser.add_argument('-p', '--provenance', default=False, action='store_true',
                        help='Whether to add a conform_prov attribute to each variable '
                             'storing the provenance information generated as execution time '
                             '[Default: False]')
    parser.add_argument('-s', '--serial', default=False, action='store_true',
                        help='Whether to run in serial (True) or parallel '
                             '(False). [Default: False]')
    parser.add_argument('infiles', metavar='INFILE', nargs='*', type=str,
                        help='Input file path or globstring specifying input '
                             'data for the PyConform operation.  If no input '
                             'files are specified, then PyConform will validate '
                             'the output specification file only, and then '
                             'exit.  [No default]')

    return parser.parse_args(argv)


#===================================================================================================
# Main Script Function
#===================================================================================================
def main(argv=None):
    args = cli(argv)

    infiles = []
    for infile in args.infiles:
        infiles.extend(glob(infile))

    if not exists(args.specfile):
        raise OSError(('Output specification file {!r} not '
                       'found').format(args.specfile))
    dsdict = json_load(open(args.specfile, 'r'), object_pairs_hook=OrderedDict)

    # Parse the output Dataset
    outds = OutputDataset(dsdict=dsdict)

    # If no input files, stop here
    if len(infiles) == 0:
        return

    # Parse the input Dataset
    inpds = InputDataset(filenames=infiles)

    # Check for warn/error
    if args.error:
        simplefilter("error", ValidationWarning)

    # Setup the PyConform data flow
    dataflow = DataFlow(inpds, outds)

    # Execute the data flow (write to files)
    dataflow.execute(chunks=dict(args.chunks), serial=args.serial, provenance=args.provenance,
                     mindate=args.mindate, maxdate=args.maxdate)


#===================================================================================================
# Command-line Operation
#===================================================================================================
if __name__ == '__main__':
    main()
