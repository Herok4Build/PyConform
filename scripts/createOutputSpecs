#!/usr/bin/env python
"""
createOutputSpecs 

Creates the Json output specification file.

COPYRIGHT: 2016, University Corporation for Atmospheric Research
LICENSE: See the LICENSE.rst file for details
"""

from argparse import ArgumentParser
from json import dump as json_dump
from pyconform import mip_table_parser
from dateutil.parser import parse

import os

_DTYPES_ = {'char': 'char', 'byte': 'int8', 'short': 'int16', 'int': 'int32',
              'float': 'float32', 'real': 'float32', 'double': 'float64'}


#=========================================================================
# parse_args
#=========================================================================
def parse_args(argv=None):

    desc = "This tool creates a specification file that is needed to run PyConform."

    parser = ArgumentParser(description=desc)
    parser.add_argument('-d', '--defFile', default=None, type=str, required=True,
                        help='A file listing the variable definitions.')
    parser.add_argument('-g', '--globalAttrFile', default=None, type=str,
                        help='A file listing the global attributes that '
                             'are common to all files.')
    parser.add_argument('-t', '--mipTable', default=None, type=str,
                        help='MIP table file.  Can be in xml, cmor, or '
                             'an Excel SS saved as a tab deliminated file.')
    parser.add_argument('-tt', '--mipTableType', default=None, type=str,
                        help='MIP table file type.  Can be xml, cmor, or excel.')
    parser.add_argument('-u', '--userList', default=None, type=str,
                        help='A file containing cf-compliant names to derive.')
    parser.add_argument('outputfile', default='out.json', type=str,
                        help='Filename for the output specification file.')

    return parser.parse_args(argv)


#=========================================================================
# load
#=========================================================================
def load(defs):

    def_dict = {}
    for line in defs:
        split = line.split('=')
        if (len(split) == 2):
            def_dict[split[0].strip()] = split[1].strip()
        else:
            if line != '\n':
                print 'Could not parse this line: ', line
    return def_dict


#=========================================================================
# Main Function
#=========================================================================
def main(argv=None):

    outSpec = {}
    args = parse_args(argv)

    print "\n"
    print "------------------------------------------"
    print 'Running createOutputSpecs with these args:\n'
    print 'Variable Definitions: ', args.defFile
    print 'Global Attributes to be added to each file: ', args.globalAttrFile
    print 'MIP Table to be used: ', args.mipTable
    print 'MIP Table Type: ', args.mipTableType
    print 'User supplied variable list: ', args.userList
    print 'Will create this spec file to use with PyConform:', args.outputfile
    print "------------------------------------------"

    # Open/Read the definition file
    if os.path.isfile(args.defFile):
        with open(args.defFile) as y_definitions:
            definitions = load(y_definitions)
            # print 'DEFINITIONS: ',definitions
    else:
        print 'Definition file does not exist: ', args.defFile
        os.sys.exit(1)

    # Open/Read the global attributes file
    attributes = {}
    if args.globalAttrFile and os.path.isfile(args.globalAttrFile):
        with open(args.globalAttrFile) as y_attributes:
            attributes = load(y_attributes)
            # print 'GLOBAL ATTRIBUTES: ',attributes
    else:
        if args.globalAttrFile and not os.path.isfile(args.globalAttrFile):
            print 'Global Attributes file does not exist: ', args.globalAttrFile
            os.sys.exit(1)

    table_dict = {}
    variables = {}
    axes = {}
    table_info = {}
    # Open/Read the MIP table
    if args.mipTable != None and args.mipTableType != None:
        table_dict = mip_table_parser.mip_table_parser(
            args.mipTable, type=args.mipTableType)
        variables = table_dict['variables']
        axes = table_dict['axes']
        table_info = table_dict['table_info']
        attributes.update(table_info)
        if 'generic_levels' in table_info.keys():
            g_levels = table_info['generic_levels']
            g_split = g_levels.split(' ')
            for l in g_split:
                axes[l] = {}
    # print '\n\n',variables.keys(),'\n\n'#,axes,'\n',table_info

    # Get variables needed to piece together the filename
    if args.mipTable != None:
        temp = os.path.split(args.mipTable)
        table = temp[len(temp) - 1]
        if ('model_id') in attributes.keys():
            model = '_' + attributes['model_id']
        else:
            model = ''
        ripgf_list = ['realization_index', 'initialization_index',
                      'physics_index', 'forcing_index', 'grid_index']
        if all(ripgf in attributes for ripgf in ripgf_list):
            experiment = ("_r{0}i{1}p{2}f{3}g{4}".format(attributes['realization_index'],
                                                         attributes[
                                                             'initialization_index'],
                                                         attributes[
                                                             'physics_index'],
                                                         attributes[
                                                             'forcing_index'],
                                                         attributes['grid_index']))
        else:
            experiment = ''
        fn_suffix = f_name = ("{0}{1}{2}.nc".format(table, model, experiment))
        attributes['experiment_id'] = table
        attributes['experiment'] = table

        # Do we need to add anything to further_info_url?
        if 'further_info_url' in attributes.keys():
            fiu_split = str(attributes['further_info_url']).split('/')
            if table not in fiu_split:
                attributes['further_info_url'] = str(
                    attributes['further_info_url']) + '/' + table
            if experiment not in fiu_split:
                attributes['further_info_url'] = str(
                    attributes['further_info_url']) + '/' + experiment
    else:
        fn_suffix = ".nc"

    # Create Output Spec
    # First add global attributes that are common to all files
    outSpec["attributes"] = attributes

    var_list = {}
    # For each variable in the definition file, create a file entry in the
    # spec and define it
    for v, d in variables.iteritems():
        if v in definitions.keys():
            f_name = ("{0}_{1}".format(v, fn_suffix))
            f_id = v
            var = {}
            for k1, v1 in variables[v].iteritems():
                if not isinstance(v1, (list, str, float)):
                    variables[v][k1] = "None"
            var["attributes"] = variables[v]
            var["definition"] = definitions[v]
            var["filename"] = f_name
            if 'type' in variables[v].keys():
                var["datatype"] = _DTYPES_[variables[v]['type']]
            if 'dimensions' in variables[v].keys():
                var["dimensions"] = variables[v]['dimensions'].split('|')
            var_list[f_id] = var
        else:
            print v, ' is being requested by the experiment, but a definition has not been supplied.'

    # Add axes into the variable list
    for v, d in axes.iteritems():
        f_id = v
        var = {}
        var["attributes"] = axes[v]
        if 'type' in axes[v].keys():
            var["datatype"] = _DTYPES_[axes[v]['type']]
        var_list[f_id] = var

    # Go through a user supplied list if specified
    if args.userList and os.path.isfile(args.userList):
        with open(args.userList) as f:
            for vr in f:
                vr = vr.strip()
                if vr != "":
                    var = {}
                    f_id = vr
                    if vr in definitions.keys():
                        var["attributes"] = {}
                        var["definition"] = definitions[vr]
                        f_name = ("{0}{1}".format(vr, fn_suffix))
                        var["filename"] = f_name
                        var["datatype"] = "None"
                        var["dimensions"] = "None"
                        var_list[f_id] = var
                    else:
                        print vr, ' is being requested by the experiment, but a definition has not been supplied.'
    else:
        if args.userList and not os.path.isfile(args.userList):
            print 'The User Variable List file does not exist: ', args.userList
            os.sys.exit(1)

    outSpec["variables"] = var_list

#    for k,v in outSpec.iteritems():
#       print '\n',k
#       for k2,v2 in v.iteritems():
#           print k2,v2

#    print 'Number of Variables: ', len(outSpec.keys())

    # Write the JSON output spec file
    with open(args.outputfile, 'w') as outfile:
        json_dump(outSpec, outfile, sort_keys=True, indent=4)


 #=========================================================================
 # COMMAND-LINE EXECUTION
 #=========================================================================
if __name__ == '__main__':
    main()
