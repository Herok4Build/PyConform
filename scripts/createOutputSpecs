#! /usr/bin/env python
"""
createOutputSpecs 

Creates the Json output specification file.

COPYRIGHT: 2016, University Corporation for Atmospheric Research
LICENSE: See the LICENSE.rst file for details
"""

import argparse, os
import json
import mip_table_parser
from dateutil.parser import parse
import datetime

data_types = {'char': 'char', 'byte': 'int8', 'short': 'int16', 'int': 'int32',
              'float': 'float32', 'real': 'float32', 'double': 'float64', 'integer':'int32'}

def parseArgs(argv = None):

    desc = "This tool creates a specification file that is needed to run PyConform."

    parser = argparse.ArgumentParser(prog='createOutputSpecs',
                                     description=desc)
    parser.add_argument('-d', '--defFile', default=None, type=str,
                        help='A file listing the variable definitions.', required=True)
    parser.add_argument('-g', '--globalAttrFile', default=None, type=str,
                        help='A file listing the global attributes that ' 
                             'are common to all files.')
    parser.add_argument('-e', '--exp', default=None, type=str,
                        help='The name of the experiment.')
    parser.add_argument('-m', '--mipTable', default=None, type=str,
                        help='The name of the MIP table.')
    parser.add_argument('-tt', '--mipTableType', default=None, type=str,
                        help='MIP table file type.  Can be xml, cmor, or excel.')
    parser.add_argument('-u', '--userList', default=None, type=str,
                        help='A file containing cf-compliant names to derive.')
    parser.add_argument('-o', '--outputpath', default=os.getcwd(), type=str,
                        help='Output pathname for the output specification file(s).')

    return parser.parse_args(argv)

def load(defs):

    def_dict = {}
    for line in defs:
        split = line.split('=')
        if (len(split) == 2):
            def_dict[split[0].strip()] = split[1].strip()
        else:
            if line != '\n':
                print 'Could not parse this line: ',line
    return def_dict

def create_output(table_dict, id, definitions, attributes, output_path, args):

    outSpec = {}
    variables = {}
    axes = {}
    table_info = {}

    variables = table_dict['variables']
    axes = table_dict['axes']
    table_info = table_dict['table_info']
    attributes.update(table_info)
    if 'generic_levels' in table_info.keys():
        g_levels = table_info['generic_levels']
        g_split = g_levels.split(' ')
        for l in g_split:
            axes[l] = {}
    #print '\n\n',variables.keys(),'\n\n'#,axes,'\n',table_info

    # Get variables needed to piece together the filename
    identifier = id
    if ('model_id') in attributes.keys():
        model = attributes['model_id']
    else:
        model = ''
    experiment = args.exp
    ripgf_list = ['realization_index','initialization_index','physics_index','forcing_index','grid_index']
    if all (ripgf in attributes for ripgf in ripgf_list):
        ripfg = ("r{0}i{1}p{2}f{3}g{4}".format(attributes['realization_index'],
                                                     attributes['initialization_index'],
                                                     attributes['physics_index'],
                                                     attributes['forcing_index'],
                                                     attributes['grid_index']))
    else:
        ripfg = ''
    table = identifier
    attributes['experiment_id'] = table
    attributes['experiment'] = table
    today = datetime.datetime.now()
    version = 'v'+str(today.year).zfill(4)+str(today.month).zfill(2)+str(today.day).zfill(2) 

    # Do we need to add anything to further_info_url?
    if 'further_info_url' in attributes.keys():
        fiu_split = str(attributes['further_info_url']).split('/')
        if table not in fiu_split:
            attributes['further_info_url'] =  str(attributes['further_info_url'])+'/'+table
        if experiment not in fiu_split:
            attributes['further_info_url'] =  str(attributes['further_info_url'])+'/'+experiment

    # Create Output Spec
    # First add global attributes that are common to all files
    outSpec["attributes"] = attributes

    var_list = {}

    # For each variable in the definition file, create a file entry in the spec and define it
    for v,d in variables.iteritems():
        if v in definitions.keys():
            tper = variables[v]['frequency']
            component = variables[v]['modeling_realm']
            if ' ' in component:
                component = component.replace(' ','_') 
            f_name = ("{0}/{1}/{2}/{3}/{4}/{5}/{6}/{7}_{8}_{9}_{10}_{11}".format(experiment,
                       tper,component,table,ripfg,version,v,
                       v,table,model,experiment,ripfg))
            f_id = v
            var = {}
            for k1,v1 in variables[v].iteritems():
                if not isinstance(v1,(list,str,float)):
                    variables[v][k1] = "None"
            var["attributes"] = variables[v]
            var["definition"] = definitions[v]
            var["filename"] = f_name
            if 'type' in variables[v].keys() and variables[v]['type'] != 'None' and variables[v]['type'] != '':
                var["datatype"]  = data_types[variables[v]['type']]
            else:
                var["datatype"] = 'None'
            if 'requested' in variables[v].keys():
                if variables[v]['requested'] != '':
                    var['data'] = variables[v]['requested']
            if 'dimensions' in variables[v].keys():
                var["dimensions"] = variables[v]['dimensions'].split('|')
            var_list[f_id] = var
        else:
            print id, ':', v, ' is being requested by the experiment, but a definition has not been supplied.'

    # Add axes into the variable list
    for v,d in axes.iteritems():
        f_id = v
        var = {}
        var["attributes"] = axes[v]
        if 'type' in axes[v].keys():
            var["datatype"]  = data_types[axes[v]['type']]
        if 'requested' in axes[v].keys():
            if axes[v]['requested'] != '':
                var['data'] = axes[v]['requested']
        var_list[f_id] = var

    # Go through a user supplied list if specified
    if args.userList and os.path.isfile(args.userList):
        with open(args.userList) as f:
            for vr in f:
                vr = vr.strip()
                if vr != "":
                    var = {}
                    f_id = vr
                    if vr in definitions.keys():
                        var["attributes"] = {}
                        var["definition"] = definitions[vr]
                        f_name = ("{0}{1}".format(vr,fn_suffix))
                        var["filename"] = f_name
                        var["datatype"]  = "None"
                        var["dimensions"] = "None"
                        var_list[f_id] = var
                    else:
                        print vr, ' is being requested by the experiment, but a definition has not been supplied.'
    else:
        if args.userList and not os.path.isfile(args.userList):
            print 'The User Variable List file does not exist: ',args.userList
            os.sys.exit(1)

    outSpec["variables"] = var_list

    # Write the JSON output spec file
    f = output_path + '/' + experiment + '_' + id + '_spec.json'
    if not os.path.exists(output_path):
        os.makedirs(output_path)
    with open(f, 'w') as outfile:
        json.dump(outSpec, outfile, sort_keys=True, indent=4)



def main(argv=None):
   
    args = parseArgs(argv)
    
    print "\n" 
    print "------------------------------------------"
    print 'Running createOutputSpecs with these args:\n'
    print 'Variable Definitions: ', args.defFile
    print 'Global Attributes to be added to each file: ', args.globalAttrFile
    print 'Experiment Name: ', args.exp
    print 'MIP Table to be used: ', args.mipTable
    print 'MIP Table Type: ',args.mipTableType
    print 'User supplied variable list: ',args.userList
    print 'Will create output spec files within this directory:', args.outputpath
    print "------------------------------------------"

    # Open/Read the definition file
    if os.path.isfile(args.defFile):
        with open(args.defFile) as y_definitions:
            definitions = load(y_definitions)
            #print 'DEFINITIONS: ',definitions
    else:
        print 'Definition file does not exist: ',args.defFile
        os.sys.exit(1)

    # Open/Read the global attributes file
    attributes = {}
    if args.globalAttrFile and os.path.isfile(args.globalAttrFile):
        with open(args.globalAttrFile) as y_attributes:
            attributes = load(y_attributes)
            #print 'GLOBAL ATTRIBUTES: ',attributes
    else:
        if args.globalAttrFile and not os.path.isfile(args.globalAttrFile):    
            print 'Global Attributes file does not exist: ',args.globalAttrFile
            os.sys.exit(1)

    # Open/Read the MIP table
#    if args.mipTable != None and args.mipTableType != None and args.exp != None:
    if args.mipTableType != None and args.exp != None:
        exp_dict = mip_table_parser.mip_table_parser(args.exp, args.mipTable,type=args.mipTableType)

    # Write the spec files out to disk
    for t in exp_dict.keys():
        create_output(exp_dict[t], t, definitions, attributes, args.outputpath, args)

    for t in sorted(exp_dict.keys()):
        print t, len(exp_dict[t]['variables'])
 
if __name__ == '__main__':
    main()
